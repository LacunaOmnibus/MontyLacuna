

Left off testing the shipbuilder.  Use 1.1 on PT - I've lowered a couple of 
the SYs there.

See CHECK in appthreads.py




QtCore docs:
    https://deptinfo-ensip.univ-poitiers.fr/ENS/pyside-docs/PySide/QtCore/

QtGui (individual widget) docs:
    https://deptinfo-ensip.univ-poitiers.fr/ENS/pyside-docs/PySide/QtGui/



Right now, both ships/ and abbreviations/ have their own media/ 
subdirectories.  I'm thinking about making a single media/ directory as a 
subdirectory of gui/ (so sibling to ships/ and abbreviations/).

This would keep us from having duplicate media files in the repo, one for each 
gui program.

IF YOU DO THIS KEEP IN MIND that I already deleted the lacuna images from 
under abbreviations/media/!   Use ships/media/, which is complete, as your 
template!





TBD:
    - If ship build threads are running and the mainwindow closes down, there 
      needs to be an onShutdown (or some such) event in mainwindow that knows 
      enough to join and exit all of those builder threads.
    - Investigate; I think this sets the size of the main window:
        self.setGeometry( 150, 150, 650, 350)


STRUCTURE {#{{{
    
    bin/
        - rungui.py
            Runs the GUI program.
        - make_ui.sh
            - Creates/updates the files in lib/gui/ based on .ui files found 
              in ui/   

    lib/gui/
        Auto-generated files containing the GUI elements.  Files in here 
        should not be edited by hand; the edits will be overwritten.

    lib/widgets/
        Custom modules that import the GUI elements in lib/gui/
}#}}}
CREATING A NEW GUI ELEMENT {#{{{

    - Each GUI element has three main files.  I'm using my ConfBox as an 
      example.
        - ui/confbox.ui
        - lib/gui/ui_confbox.py
        - lib/widgets/confbox.py

        - It's recommended that you open that .ui file in Qt Designer and the 
          two .py files in a text editor right now to better understand what 
          the rest of this note is talking about.

    - Design your element in Qt Designer.
        - Save the file into ui/FILENAME.ui

    - Add it to the build script
        - Edit bin/make_ui.sh.  Add your file to the FILE_PIECES array.
            - You're just adding the root of your filename.  So if the file 
              you just saved was "ui/myelement.ui", all you're adding to that 
              FILE_PIECES array will be "myelement".
        - Run bin/make_ui.sh to create lib/gui/ui_FILENAME.py

    - Add your new element to the gui and widgets packages.
        - lib/gui/__init__.py
        - lib/widgets/__init__.py
            - Follow existing examples for both of these files.

    - Create custom code for your design
        - Create lib/widgets/FILENAME.py
        - Your new file will need some specific imports
            from PySide.QtGui import QApplication, QT_CLASS

                - Most custom code will require QApplication, so adding that 
                  now is fine.
                - The QT_CLASS is the type of Qt window your element inherits 
                  from.  In QtDesigner, see the Object Inspector panel - 
                  you're looking for the "Class" of the toplevel object in a 
                  given design.
                    - eg for confbox.ui, the QT_CLASS you need to import is 
                      QDialog.

            from gui import Ui_CLASS
                - Ui_CLASS is the name of the class found in 
                  lib/gui/ui_FILENAME.py.  This classname is autogenerated, so 
                  don't get clever and rename it.

        - Create your class
            class MyClass( QT_CLASS, Ui_CLASS ):
                def __init__(self, parent=None):
                    super(MyClass, self).__init__(parent)
                    self.setupUi(self)

            - Your class will inherit from both of the classes we imported.  
              __init__ must call super on MyClass (obviously change this to 
              whatever you're calling your class), and then call setupUi().

            - At this point, the rest of your MyClass() will contain whatever 
              code you need it to.

    - Update the widgets package to add your new element
        - lib/widgets/__init__.py
        - Follow existing examples

    - At this point, your new widget should be ready to go.  You'll most 
      likely want to use it in lib/widgets/mainwindow.py -- see existing 
      examples for how to use widgets (search for "ConfBox")
    
}#}}}
ADDING IMAGES {#{{{

    Icon packs often come with hundreds of images, of which I only use a 
    handful, and I don't want to force the users to have to download all those 
    unused images.

    So I'm storing media packs in ~/work/Media/, which is a github repo.  When 
    I find an image (or sound or whatever) that I want to include in Monty, 
    I'll copy it over here then.

    QUICK INSTRUCTIONS {#{{{
        - Copy the image you want to use from that Media repo into a directory 
          that makes sense under MONTYINSTALL/pyside/media/images/
            - Convert it to a png if it's something else.
        - Edit ui/menu_icons.qrc.  Add an alias and the path to the file, 
          following existing examples.
            - The paths must be relative to the location of the coolicons.qrc 
              file.
            - Feel free to create a new .qrc file if it makes sense to do so, 
              but edit bin/make_ui.sh and lib/gui/__init__.py if you do.
        - Re-run bin/make_ui.sh
        - Your new image is now available to the program.
    }#}}}
    ADDING A NEW ICON PACK {#{{{
        - Download it and put it somewhere intelligent under media/.
        - Either edit the existing ui/menu_icons.qrc file (for toolbar icons), 
          or create a new .qrc file as makes sense.
        - If you created a new .qrc file, edit bin/make_ui.sh
            - Add your new file's name, minus the ".qrc" extension, to 
              IMAGE_PIECES.
        - Run bin/make_ui.sh
        - Edit lib/gui/__init__.py
            - Add "import gui.img_YOUR_NEW_PACKNAME"
            - the "img_" got stuck on the front by bin/make_ui.sh.
        

        If you're planning on adding a new icon pack with essentially the same 
        icons provided by coolicons.qrc, to allow for "skinning", I think 
        we're going to need to use different aliases for each image 
        (ci_close.png for "coolicon close", op_close.png for "otherpack 
        close", etc).  It looks like the aliases are being brought in as 
        globals.

        You could give each icon the same alias, and then control which icon 
        pack gets loaded by only having one pack imported by 
        lib/gui/__init__.py, but that wouldn't allow the user to pick his skin 
        while the program is running.

        If each pack has its own hungarian notation on the front of each 
        alias, we could change the images used based on a user choice (if we 
        really wanted to bother with that).

    }#}}}
    CONVERT SVG TO PNG {#{{{
        $ sudo apt-get install librsvg2-bin
        $ rsvg-open FILE.svg -f png -o FILE.png

        Conversion is almost instant.
    }#}}}
}#}}}
CYTHONIZE A MODULE {#{{{

    DO NOT DO THIS FOR GUI WIDGET MODULES.
    
    I did this with the About window, but that's the only GUI module it works 
    for.  All the others end up producing "maximum recursion depth exceeded" 
    exceptions.  
    
    And since I don't really need my About window to be FASTAR, I'm no longer 
    bothering to cythonize it.  No need to complicate things for no benefit.

    But the fact that it worked for the About window means to me that it 
    should work for any non-gui class files I might have lying around.  If 
    there's compute-intensive code anywhere, put it in its own class in a 
    separate file and cythonize it.


    $ cd lib/widgets/
    $ mv FILE.py FILE.pyx
    - Edit __init__.py to add the two "pyximport" lines
        - Adding these pyximport lines are really all that needs to change in 
          the rest of the code.
    - Edit setup.py
        - This is the standard cython setup.py script - see my cython notes 
          for a copy/paste.
            - the cythonize() call in that copy accepts either a single file 
              or a list of files.
        - Add your new FILE.pyx to the list of files being cythonized and 
          re-run that setup.py script
            $ py setup.py build_ext --inplace

    That should be in; your module is now written in C.

}#}}}
THREADED TLE REQUEST CLASSES {#{{{

The two main forum threads where I got the info to create this stuff are:
    http://stackoverflow.com/questions/2823112/communication-between-threads-in-pyside
    http://www.matteomattei.com/pyside-signals-and-slots-with-qthread-example/



There are a bunch of these classes in appthread.py, and at least one at the 
bottom of myapp.py (CHECK which should get moved to appthread.py).  Look for 
this section:
                    ###########################
                    # Threaded TLE requestors #
                    ###########################


The getter objects have a request() method that starts the thread, waits for 
it to finish, constantly updates the UI for you so it doesn't freeze up, and 
returns the main value::
    planet_getter = GetPlanet( self.parent.app, pname )
    planet = planet_getter.request()
    print( "We got the planet", planet.name )

That 'planet' return value is also, after the request() call, an attribute of 
the getter itself:
    print( "We got the planet", planet_getter.planet.name )



If you need more control over the threads than request() gives you, you could 
do something like this:

    def get_data(self, data):
        print( "get_data got back this:", data )

    scuttler_thread = MassShipScuttler( myapp, spaceport, ids_to_delete )
    scuttler_thread.dataReady.connect(self.get_data, Qt.QueuedConnection)
    scuttler_thread.start()
    while scuttler_thread.isRunning():
        sys.stdout.write('.')
        sys.stdout.flush()
        myapp.processEvents()
        time.sleep(0.1)

    print( "\nNow we're done." )

There's nothing magical about "dataReady" -- it's just a signal that each of 
my threaded TLE getters implements and emits (see the code for examples).



HOWEVER, be aware that this simply does not work:

    def get_data(self, data):
        print ( "in get_data, I have this data:", data )
        self.mydata = data

    thread = ThreadedClass( )
    thread.dataReady.connect(self.get_data, Qt.QueuedConnection)
    thread.start()
    while thread.isRunning():
        app.processEvents()
        time.sleep(0.1)

    print( self.mydata )        # GONG!


What I'm trying to do here is have the thread get some data (which it does), 
and then set that data into an attribute in my current object (which it does 
not).

The print line in get_data() works just fine.  But when we get back to the 
GONG line, we do NOT have 'mydata' set in self.  I still don't quite 
understand Python objects completely, I guess.

}#}}}

