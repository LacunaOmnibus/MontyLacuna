

When making long requests (eg getting ships for a planet) I really need to be 
doing that in a thread to not block the UI.


Closure problem with the buttons in the ships table explained here:
    http://docs.python-guide.org/en/latest/writing/gotchas/

    See "Late Binding Closures".




QtCore docs:
    https://deptinfo-ensip.univ-poitiers.fr/ENS/pyside-docs/PySide/QtCore/

QtGui (individual widget) docs:
    https://deptinfo-ensip.univ-poitiers.fr/ENS/pyside-docs/PySide/QtGui/

STRUCTURE {#{{{
    
    bin/
        - rungui.py
            Runs the GUI program.
        - make_ui.sh
            - Creates/updates the files in lib/gui/ based on .ui files found 
              in ui/   

    lib/gui/
        Auto-generated files containing the GUI elements.  Files in here 
        should not be edited by hand; the edits will be overwritten.

    lib/widgets/
        Custom modules that import the GUI elements in lib/gui/
}#}}}
CREATING A NEW GUI ELEMENT {#{{{

    - Each GUI element has three main files.  I'm using my ConfBox as an 
      example.
        - ui/confbox.ui
        - lib/gui/ui_confbox.py
        - lib/widgets/confbox.py

        - It's recommended that you open that .ui file in Qt Designer and the 
          two .py files in a text editor right now to better understand what 
          the rest of this note is talking about.

    - Design your element in Qt Designer.
        - Save the file into ui/FILENAME.ui

    - Add it to the build script
        - Edit bin/make_ui.sh.  Add your file to the FILE_PIECES array.
            - You're just adding the root of your filename.  So if the file 
              you just saved was "ui/myelement.ui", all you're adding to that 
              FILE_PIECES array will be "myelement".
        - Run bin/make_ui.sh to create lib/gui/ui_FILENAME.py

    - Add your new element to the gui and widgets packages.
        - lib/gui/__init__.py
        - lib/widgets/__init__.py
            - Follow existing examples for both of these files.

    - Create custom code for your design
        - Create lib/widgets/FILENAME.py
        - Your new file will need some specific imports
            from PySide.QtGui import QApplication, QT_CLASS

                - Most custom code will require QApplication, so adding that 
                  now is fine.
                - The QT_CLASS is the type of Qt window your element inherits 
                  from.  In QtDesigner, see the Object Inspector panel - 
                  you're looking for the "Class" of the toplevel object in a 
                  given design.
                    - eg for confbox.ui, the QT_CLASS you need to import is 
                      QDialog.

            from gui import Ui_CLASS
                - Ui_CLASS is the name of the class found in 
                  lib/gui/ui_FILENAME.py.  This classname is autogenerated, so 
                  don't get clever and rename it.

        - Create your class
            class MyClass( QT_CLASS, Ui_CLASS ):
                def __init__(self, parent=None):
                    super(MyClass, self).__init__(parent)
                    self.setupUi(self)

            - Your class will inherit from both of the classes we imported.  
              __init__ must call super on MyClass (obviously change this to 
              whatever you're calling your class), and then call setupUi().

            - At this point, the rest of your MyClass() will contain whatever 
              code you need it to.

    - Update the widgets package to add your new element
        - lib/widgets/__init__.py
        - Follow existing examples

    - At this point, your new widget should be ready to go.  You'll most 
      likely want to use it in lib/widgets/mainwindow.py -- see existing 
      examples for how to use widgets (search for "ConfBox")
    
}#}}}
ADDING IMAGES {#{{{
    QUICK INSTRUCTIONS {#{{{
        - Find the image you want to add (under media/images/coolicons/png/)
        - Edit ui/menu_icons.qrc.  Add an alias and the path to the file, 
          following existing examples.
            - The paths must be relative to the location of the coolicons.qrc 
              file.
        - Re-run bin/make_ui.sh
        - Your new image is now available to the program.
    }#}}}
    ADDING A NEW ICON PACK {#{{{
        - Download it and put it somewhere intelligent under media/.
        - Either edit the existing ui/menu_icons.qrc file (for toolbar icons), 
          or create a new .qrc file as makes sense.
        - If you created a new .qrc file, edit bin/make_ui.sh
            - Add your new file's name, minus the ".qrc" extension, to 
              IMAGE_PIECES.
        - Run bin/make_ui.sh
        - Edit lib/gui/__init__.py
            - Add "import gui.img_YOUR_NEW_PACKNAME"
            - the "img_" got stuck on the front by bin/make_ui.sh.
        

        If you're planning on adding a new icon pack with essentially the same 
        icons provided by coolicons.qrc, to allow for "skinning", I think 
        we're going to need to use different aliases for each image 
        (ci_close.png for "coolicon close", op_close.png for "otherpack 
        close", etc).  It looks like the aliases are being brought in as 
        globals.

        You could give each icon the same alias, and then control which icon 
        pack gets loaded by only having one pack imported by 
        lib/gui/__init__.py, but that wouldn't allow the user to pick his skin 
        while the program is running.

        If each pack has its own hungarian notation on the front of each 
        alias, we could change the images used based on a user choice (if we 
        really wanted to bother with that).

    }#}}}
    CONVERT SVG TO PNG {#{{{
        $ sudo apt-get install librsvg2-bin
        $ rsvg-open FILE.svg -f png -o FILE.png

        Conversion is almost instant.
    }#}}}
}#}}}
CYTHONIZE A MODULE {#{{{

    DO NOT DO THIS FOR GUI WIDGET MODULES.
    
    I did this with the About window, but that's the only GUI module it works 
    for.  All the others end up producing "maximum recursion depth exceeded" 
    exceptions.  
    
    And since I don't really need my About window to be FASTAR, I'm no longer 
    bothering to cythonize it.  No need to complicate things for no benefit.

    But the fact that it worked for the About window means to me that it 
    should work for any non-gui class files I might have lying around.  If 
    there's compute-intensive code anywhere, put it in its own class in a 
    separate file and cythonize it.


    $ cd lib/widgets/
    $ mv FILE.py FILE.pyx
    - Edit __init__.py to add the two "pyximport" lines
        - Adding these pyximport lines are really all that needs to change in 
          the rest of the code.
    - Edit setup.py
        - This is the standard cython setup.py script - see my cython notes 
          for a copy/paste.
            - the cythonize() call in that copy accepts either a single file 
              or a list of files.
        - Add your new FILE.pyx to the list of files being cythonized and 
          re-run that setup.py script
            $ py setup.py build_ext --inplace

    That should be in; your module is now written in C.

}#}}}

NOTES ON INDIVIDUAL BITS OF THE GUI {#{{{
    
    Abbreviation Table Sizing {#{{{
        The width of the two columns is based on the width of the whole table.  
        The Name column gets 75% and the Abbrv column gets 25% of the overall 
        width.

        However, this table appears on the third tab, and the login button is 
        on the first tab.  Clicking the login button creates the table with 
        its contents.

        If the user doesn't view that third tab containing the table before 
        they log in (and why would they?), then the table's width will be 100, 
        regardless of the size of the rest of the app.  Since the widget the 
        table lives in hasn't been viewed yet, it takes on that 100 as a 
        default width.

        This is why there's a tab_changed() method hooked up to the tab 
        widget.  As soon as the user clicks on the tab containing that abbrv 
        table, it gets resized properly.
    }#}}}

}#}}}

