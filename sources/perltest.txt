.. highlight:: perl

Perl Test
=========

I'm wanting to keep this class framework-agnostic, so you're not stuck using 
Catalyst if you don't want to.

However, you're often going to want to, and this method saves some typing if 
that's the case.

Tell your controller's begin method when to do JSON RPC 2.0 stuff.  That's 
often going to be whenever you're hit via POST, but it's up to your controller 
to decide that:


.. code-block:: perl

  use JSON::RPC20;
  sub begin :Private {
   my ( $self, $c ) = @_;
   if( $c->req->method eq 'POST' ) {
    JSON::RPC20->run_for_catalyst($c, $self);
   }
  }


That performs all the parsing and routing.  All you have to do is ensure that 
any methods that the user might request exist in your controller as private 
methods that accept JSON::RPC20 and JSON::RPC20::Request objects after the 
usual $self and $c, and which call set_response() on that JSON::RPC20 object:


.. code-block:: perl

  sub some_user_callable_method :Private {
     my( $self, $c, $jsonrpc, $req ) = @_;
     my $rslt = {username => $req->params->[0], password => $req->params->[1]};
     $jsonrpc->set_response( $req, $rslt );
  }
 
  sub some_other_user_callable_method :Private {
     my( $self, $c, $jsonrpc, $req ) = @_;
     my $rslt = {email => $req->params->[0], age => $req->params->[1]};
     $jsonrpc->set_response( $req, $rslt );
  }
 
  sub YA_ucm :Private { ... }


The request_string attribute is required, so we normally need to be called as:
    my $trans = JSON::RPC20->new({ request_string => $string });

But we want to allow the user to save some typing, so we'll also allow:
    my $trans = JSON::RPC20->new( $string );

And since we'll often be used from a Catalyst app, and Catalyst may well be 
returning a File::Temp object in $c->req->body, we'll also allow:
    my $trans = JSON::RPC20->new( <File::Temp object> );

Checks each individual request hashref (there will often be only one) for 
validity.

Generates request and response objects objects from the request hashref.  If 
the request was invalid, the response object will have its error attribute 
set.

Returns all request objects in the current transaction as a list, sorted 
ascending by their IDs.

Sets the result for a given request.

Your code calls the method indicated by $request->method, which needs to 
return some result.  Pass both the request and the produced response to 
set_response.

$rslt can be EITHER:
    - The actual result returned by the requested method
    - An JSON::RPC20::Error object representing whatever error was 
      encountered by the requested method.


.. code-block:: perl

  my $meth = $req->method;
  my $rslt = $some_class->$meth();
  $txn->set_response( $req, $rslt );


in $some_class:


.. code-block:: perl

  sub the_example_method_being_called {
   if( something_went_wrong ) {
    my $err = JSON::RPC20::Error->new();
    $err->invalid_params();             # or whatever
    return $err;
   }
 
   my $hr = { the_answer_is => 42 };
   return $hr;
  }


Returns $self->responses as a JSON-encoded string to be passed back to the 
user.

Before encoding responses, set_response() must first be called for each 
request.


.. code-block:: perl

  my $txn = JSON::RPC20->new({ request_string => $json_string });


or, to save a little typing...


.. code-block:: perl

  my $txn = JSON::RPC20->new( $json_string );
  foreach my $req( @{$txn->requests} ) {
      - Call the code in $req->method, and get a result (eg in $rslt).
      $txn->set_response( $req, $rslt );
  }
  send_to_user( $txn->encode_responses() );


encode_responses() returns the correct response even if the $json_string 
handed in by the user was an invalid JSON RPC 2.0 request, or even if it's 
unparseable json.

However, in those two cases, $self->success will be set to 0 so you can 
manually cope with it if you need to.

AUTHENTICATION
Some JSON requests will require authentication.  This will often follow the flow:
 - user sends JSON request to /json_login including the params 'username' and 
   'password'
 - app checks those creds.  If correct, app hands back a session ID.
 - user then includes that session ID as a param in any future requests to 
   modules/methods that require auth.  Those modules/methods are responsible 
   for checking that session ID.

In the case of a batch of requests, we have two options:
 - Authenticate each request in the batch separately.  Each request requires a 
   session ID (though all may be the same value), and each request's session 
   is checked individually.
- Authenticate the batch once, and assume that each request within the batch 
  is using the same authentication.  Mark the entire batch as authenticated, 
  and don't re-auth each individual request.

